
pragma solidity ^0.4.16;


//
// two-party payment contract
//
// (c) David Lancashire, Proclus Technologies (July 31, 2018)
//
contract ValidateSaito {

    address owner;

    uint channel = 0;
    mapping (uint => address)   private address1;
    mapping (uint => address)   private address2;
    mapping (uint => uint)      private address1_deposit;
    mapping (uint => uint)      private address2_deposit;
    mapping (uint => uint)      private withdrawal;
    mapping (uint => uint)      private sigindex;
    mapping (uint => uint)      private block_id;

    /////////////////
    // constructor //
    /////////////////
    function ValidateSaito() {
        owner = msg.sender;
    }



    ////////////////////
    // create channel //
    ////////////////////
    //
    // create a two-party channel by submitting an array containing:
    //
    // publickey of party1
    // publickey of party2
    // ... and a deposit
    //
    function createChannel(address add1, address add2) public payable returns (uint) {

        // users
        address1[channel] = add1;
        address2[channel] = add2;

        // initialize
        address1_deposit[channel]    = msg.value;
        address2_deposit[channel]    = 0;

        block_id[channel]          = 0;
        withdrawal[channel]        = 0;
        sigindex[channel]          = 0;

        channel++;

        return channel-1;
     
    }


    
    function deposit(uint channel_id, address deposit_address) public payable returns (uint) {

        // users
        if (deposit_address == address1[channel_id]) {
            address1_deposit[channel_id]    += msg.value;
            return;
        }
        if (deposit_address == address2[channel_id]) {
            address2_deposit[channel_id]    += msg.value;
            return;
        }
        
        // TODO: return the funds to sender if no match

    }



    function checkBalanceAddress1(uint channel_id) returns (uint) {
        return address1_deposit[channel_id];
    }
    function checkBalanceAddress2(uint channel_id) returns (uint) {
        return address2_deposit[channel_id];
    }



    //////////////
    // withdraw //
    //////////////
    //
    // withdrawal attempts require uploading signatures
    // from both parties. If the sigindex is 0, a waiting
    // period is established. If the sigindex is greater
    // than 0, we are responding to a withdrawal attempt
    // and get instant payment.
    //
    // note that too many local variables triggers "stack 
    // too deep" error messages, so we re-use variable names.
    //
    function withdraw(uint channel_id, uint withdrawal1, uint sig1, bytes32 r1, bytes32 s1, uint withdrawal2, uint sig2, bytes32 r2, bytes32 s2) returns (uint) {

      // ensure sigs are sequential
      if (sig1 > sig2) {
          if (sig2+1 != sig1) { return 0; }
      } else {
          if (sig2 != sig1) {
              if (sig2 != sig1+1) { return 0; }
          }
      }
      
      // ensure sigs are valid
      var msg = generateMessage(withdrawal1, sig1);
      var valid = validateMessage(address1[channel_id], msg, r1, s1);
      if (valid == 0) { return 0; }

      msg = generateMessage(withdrawal2, sig2);
      valid = validateMessage(address2[channel_id], msg, r2, s2);
      if (valid == 0) { return 0; }

      // make sure the withdrawal is not higher than the amount committed
      if ((address1_deposit[channel_id]+address2_deposit[channel_id]) < (withdrawal1+withdrawal2)) {
        return 0;
      }
    
      
/******
      // if this is our first withdrawal attempt, we set a 
      // cooling-down period for when we will authorize this
      // withdrawal.
      if (sigindex[channel_id] == 0) { 
        sigindex[channel_id] = (sig1+sig2);
        block_id[channel_id] = block.number + 5760; // 24 hour at 15 secs
        return block_id[channel_id];
      } else {
      
        // this is a subsequent withdrawal attempt, we see 
        // if it is better than the existing withdrawal attempt
        // and restart the countdown if that is the case
        if (sigindex[channel_id] < (sig1+sig2)) {
            sigindex[channel_id] = (sig1+sig2);
            block_id[channel_id] = block.number + 5760; // 24 hour at 15 secs
            return block_id[channel_id];
        } else {
            
            // this is a subsequent withdrawal attempt, so we 
            // check that we are in a block position to withdraw
            if (block_id[channel_id] <= block.number) {
                
                // authorize withdrawals
                withdrawal[channel_id] = 1;
                address1[channel_id].transfer(withdrawal1);
                address2[channel_id].transfer(withdrawal2);
                return 5;

            }
        }
      }
******/      

      // authorize withdrawals
      withdrawal[channel_id] = 1;
      address1[channel_id].transfer(withdrawal1);
      address2[channel_id].transfer(withdrawal2);

      return 2;
      
    }



    /////////////////////////
    // generateMessageHash //
    /////////////////////////
    //
    // x = coin distribution
    // y = index signed
    //
    function generateMessage(uint x, uint y) returns (bytes32) {
        return sha256(uint2str(x), uint2str(y));
    }



    ///////////////////
    // verifyMessage //
    ///////////////////
    function validateMessage(address add1, bytes32 m, bytes32 r, bytes32 s) returns (uint) {
        if (ecrecover(m,28,r,s) == add1) { return 1; }
        if (ecrecover(m,27,r,s) == add1) { return 1; }
        return 0;
    }


    //
    // should be removed before production
    //
    function kill() {
      if (msg.sender == owner) { suicide(msg.sender); }
    }


    /////////////
    // utility //
    /////////////
    function uint2str(uint i) internal pure returns (string){
        if (i == 0) return "0";
        uint j = i;
        uint len;
        while (j != 0) {
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint k = len - 1;
        while (i != 0){
            bstr[k--] = byte(48 + i % 10);
            i /= 10;
        }
        return string(bstr);
    }

}






